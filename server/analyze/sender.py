import re
import requests
import tldextract
import dns.resolver
import os
from datetime import datetime
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

class SenderTrustAnalyzer:
    # Expanded and categorized list of free providers
    FREE_PROVIDERS = {
        "gmail.com", "yahoo.com", "hotmail.com", "outlook.com", "aol.com", 
        "icloud.com", "mail.com", "protonmail.com", "zoho.com", "yandex.com"
    }

    # Expanded list of disposable providers
    DISPOSABLE_PROVIDERS = {
        "mailinator.com", "10minutemail.com", "tempmail.com", "guerrillamail.com", 
        "trashmail.com", "temp-mail.org", "fakeinbox.com", "throwawaymail.com",
        "yopmail.com", "dispostable.com", "sharklasers.com"
    }

    # Suspicious TLDs often used for malicious purposes
    SUSPICIOUS_TLDS = {
        "xyz", "top", "click", "link", "live", "tk", "ml", "ga", "cf", "gq", 
        "club", "stream", "bid", "review", "trade", "date"
    }
    
    # Whitelist of trusted domains that should never be penalized
    TRUSTED_DOMAINS = {
        "microsoft.com", "apple.com", "google.com", "amazon.com", "facebook.com",
        "twitter.com", "linkedin.com", "adobe.com", "oracle.com", "salesforce.com",
        "ibm.com", "cisco.com", "intel.com", "dell.com", "hp.com", "sap.com"
    }

    def __init__(self):
        pass

    def extract_domain(self, email: str) -> str:
        return email.split("@")[-1].lower()

    def extract_username(self, email: str) -> str:
        return email.split("@")[0].lower()

    def is_trusted_domain(self, domain: str) -> bool:
        # Check if this is a known trusted domain
        ext = tldextract.extract(domain)
        registered_domain = f"{ext.domain}.{ext.suffix}"
        return registered_domain in self.TRUSTED_DOMAINS
        
    def is_free_provider(self, domain: str) -> bool:
        return domain in self.FREE_PROVIDERS

    def is_disposable_provider(self, domain: str) -> bool:
        return domain in self.DISPOSABLE_PROVIDERS

    def is_suspicious_tld(self, domain: str) -> bool:
        ext = tldextract.extract(domain)
        return ext.suffix in self.SUSPICIOUS_TLDS

    def is_autogenerated_username(self, username: str) -> bool:
        # Look for typical patterns in autogenerated usernames
        if re.search(r"\d{6,}", username):  # 6+ consecutive digits
            return True
        if len(username) < 3:  # Too short
            return True
        if re.search(r"^[a-z]{1,3}\d{4,}", username):  # Short prefix with many numbers
            return True
        if re.search(r"user\d+", username, re.IGNORECASE):  # Generic "userXXXX" pattern
            return True
        return False

    def looks_like_spoof(self, domain: str) -> bool:
        # Improved detection patterns for common spoofing techniques
        if self.is_trusted_domain(domain):
            return False  # Skip check for trusted domains
            
        # Better patterns focused on actual spoofing techniques
        spoof_patterns = [
            r"paypa[l1][l1]\.com",  # paypal spoofs
            r"amaz[o0]n\d*\.com",    # amazon spoofs
            r"g[o0]{2}g[l1]e\.com",  # google spoofs
            r"m[i1]cr[o0]s[o0]ft\.",  # microsoft spoofs
            r"apple-?[i1]d\.",       # apple id spoofs
            r"[a-z]+-?secure\d*\.",  # generic "secure" domains
            r"[a-z]+-?verify\d*\."   # generic "verify" domains
        ]
        
        for pattern in spoof_patterns:
            if re.search(pattern, domain, re.IGNORECASE):
                return True
        return False

    def resolve_ip(self, domain: str) -> str | None:
        try:
            answers = dns.resolver.resolve(domain, 'A')
            return answers[0].to_text()
        except Exception:
            return None

    def check_spamhaus(self, ip: str) -> bool | None:
        if not ip:
            return None
        try:
            reversed_ip = ".".join(reversed(ip.split(".")))
            query = f"{reversed_ip}.zen.spamhaus.org"
            dns.resolver.resolve(query, 'A')
            return True  # IP is blacklisted
        except dns.resolver.NXDOMAIN:
            return False  # Not listed
        except Exception:
            return None  # Error or unknown

    def analyze(self, email: str) -> dict:
        domain = self.extract_domain(email)
        username = self.extract_username(email)
        ip = self.resolve_ip(domain)
        spamhaus_blacklisted = self.check_spamhaus(ip)
        is_trusted = self.is_trusted_domain(domain)

        flags = {
            "trusted_domain": is_trusted,
            "free_provider": self.is_free_provider(domain),
            "disposable": self.is_disposable_provider(domain),
            "suspicious_tld": self.is_suspicious_tld(domain),
            "autogen_username": self.is_autogenerated_username(username),
            "spoof_like_domain": self.looks_like_spoof(domain),
            "spamhaus_blacklisted": spamhaus_blacklisted
        }

        # Compute risk score
        risk = 0
        
        # First check if domain is trusted
        if flags["trusted_domain"]:
            # For trusted domains, apply minimal risk
            risk = 0
        else:
            # Critical factors (major red flags)
            if flags["spoof_like_domain"]:
                risk += 95  # Spoofing attempts should get near-zero trust (extremely high risk)
            if flags["disposable"]:
                risk += 80  # Disposable emails are very high risk
            if flags["spamhaus_blacklisted"] == True:
                risk += 90  # Spamhaus blacklisting is extremely significant
                
            # High risk factors
            if flags["autogen_username"]:
                risk += 40  # Auto-generated usernames are suspicious
                
            # Medium risk factors
            if flags["suspicious_tld"]:
                risk += 30  # Suspicious TLD
                
            if flags["free_provider"]:
                risk += 10  # Free email providers are slightly suspicious

            else:
                risk += 25 # Risk for unknown domains
            
            
            # Compound risk - apply additional penalties for combinations
            risk_factor_count = sum(1 for f, v in flags.items() if v is True)
            if risk_factor_count > 2:
                risk += min(20, (risk_factor_count - 2) * 10)  # Add penalty for multiple flags
        
        trust_score = max(0, 100 - risk)

        return {
            "email": email,
            "domain": domain,
            "ip": ip,
            "trusted": is_trusted,
            "flags": flags,
            "trust_score": trust_score
        }
    
if __name__ == "__main__":
    print("\nSender Trust Analyzer")
    analyzer = SenderTrustAnalyzer()
    
    email = input("Enter an email address to analyze: ").strip()
    
    print(f"\nAnalyzing: {email}")
    result = analyzer.analyze(email)
    
    print(f"Trust Score: {result['trust_score']}/100")
    print(f"IP Address: {result['ip'] or 'Not resolved'}")
    
    print("Flags:")
    for flag, value in result['flags'].items():
        if flag == "trusted_domain" and value:
            print(f"  ✅ {flag}")
        elif isinstance(value, bool) and value:
            print(f"  ⚠️ {flag}")
        elif isinstance(value, (int, float)) and value > 0:
            print(f"  ⚠️ {flag}: {value}")
    print("")
